#lang racket

;; lambda


#|
语法：(lambda formals body1 body2 ...)

lambda 用来创建过程。任何创建过程和局部变量绑定的操作最终都是由lambda或case-lambda来实现的

formals是指形参，body1 body2 。。 是lambda 的主体

主体可能还包含一系列的定义，在这时这些定义的定义域是局部的
如果定义存在，那么在扩展（解析？）lambda主体的时候关键词绑定会被使用和丢弃，lambda 的主体会根据定义和剩下的bodys被转换成letrec* 表达式，以下的讨论都建立在这个转换已经做好了的基础上

当一个过程被创建后，所有的变量绑定都会保留在函数体重，除了形参。当这个过程被应用与真正的参数上时，形参
才真正绑定在真正的参数上。保留下来的环境也被恢复，函数体被解析了（eval）

一旦被应用之后，形参之中的参数将会如下形式定义

- 如果formals是一个变量的列表，比如 （x y z）,如果给出的实际变量的数量和形参定义一致那么，形参和实参一一绑定，否则会报错说参数个数不匹配

- 如果参数是单个变量，比如x，那么x绑定的是一个实参的列表

- 如果参数的形式如 （x y . z）,在点之前的参数会一一绑定在实参是而最后的一个变量会绑定剩下的实参的列表


当lambda 的函数主体被解析的时候，函数体中的表达式会挨个被解析（eval）。lambda表达式的返回值是最后一个表达式的返回值。


过程在被打印的时候不一定有统一的形式，不同的scheme解释器有不同的做法，本书中使用#<procedure> 来表示过程

|#

(lambda (x) (+ x 3))
((lambda (x) (+ x 7)) 7)

((lambda (x . y) (list x y)) 28 37)


((lambda x x) 7 13)

