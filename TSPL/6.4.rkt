#lang racket

;;scheme的数字可以分为整数,有理数,实数或者复数.这是等级制的分级制度。就是说
;;复数包括实数,实数包括有理数,有理数包括整数

;;另一种划分的方式是分为精确的数字和不精确的数字.取决于函数和函数的参数.
;;可以用判断函数exact? 和inexact?来判断数字的精确性.scheme的大部分数字都是精确的
;;如果输入都是精确的数字那么返回也会是精确地.如果精确的数字和不精确的数字混合在一起,那么返回也是不精确的
;;精确的整数和有理数可以被支持到任意精度.整数的大小或者分数的分子和分母只受系统存储的限制.

;;尽管有其他的表示可能,不精确的数字忠实地使用硬件或者系统软件规定的方式表示数字.
;;复数就是使用有序队列的方式表示.实部和虚部,实部和虚部可以使精确的整数或有理数或者浮点数.

;;scheme的数字 就是直接沿用的传统的数字记号,一个精确的整数就是一连串的数字有可能在一开始还有符号位.例如,3,+19,-1000000以及1231231231231231334442312212312都表示精确的数字.

;;精确的有理数也是使用/分开的两个整数加上可选的符号位,例如3/5,-6/5,以及1/12313123123123123343958865760504.分数会被自动约分为最简形式.


;;不精确的数字使用浮点数或者科学计数法.比如1.0,-200.0是不精确的整数,1.5,0.034
;;-10e-10以及1.5e-5是不精确的有理数,2e3等于2000.0


;;一个位数的长度也许会出现在实数的最后,或者是由浮点数或者科学计数法写的复数.位数宽度w表示数字表示中的有效的位数,位数的长度默认是53,IEEE双精度浮点数的中有效位的长度.对于非规范化的IEEE双精度浮点数,尾数的宽度小于53.如果一个scheme的实现无法指定尾数的长度,他会尽可能按照要求的的长度来表示数字,不然的话会使用最大尾数宽度来表示.

;;精确和不准确的实数被写成准确或不准确的整数或有理数,但是scheme没有规定无理数的语法.

;;复数可以使用直角坐标或者极坐标系下的表示,在指教坐标系下复数表示可以写成x+yi或者x-yi,x是整数,有理数或者实数y是无符号的整数,实数或有理数.实数部分有可能被省略.例如3+4i,3.2-3/4i,+i以及-3e-5i都是以直角坐标系下表示的复数.在极坐标系中.复数用x@y的形式,x和y是整数,有理数或实数.例如1.1@1.764以及-1@-1/2是极坐标系下的复数.


;;+inf.0和-inf.0是不精确的实数表示正无穷和负无穷.+nan.0和-nan.0表示不精确的"不是一个数字"的值.无穷可以通过除以正的或负的不精确的0得到.NaN也有可能这样得到或者通过其他的方式.

;;数字的精确性可以通过前缀#e或#i来强制表示.#e将数字强制转换为精确的,#i强制数字是不精确的.例如#e1,1/1,#e1/1,#e1.0都表示精确的1,#i3/10,0.3,#i0.3表示不精确的有理数0.3

;;数字默认都是十进制的,但是可以通过前缀指定数字的进制.
;#b(二进制)
;#o(八进制)
;#d(十进制)
;#x(16进制)
;;对于16进制而言,字符a~f代表相对十进制多出来的10~15
;;例如#b10101是十进制21的二进制表示
;;#o72和十进制的58一样大
;;但是使用浮点数和科学计数法表示的数字是十进制的.



;;(exact? num)
;(inexact? num)

(exact? 1)
(exact? -15/16)
(exact? 2.01)
(exact? #i77)
(exact? #i2/3)
(exact? 1.0-2i)


;;(= n1 n2 ...)
;;(> n1 n2 ...)
;;(< n1 n2 ...)
;;(>= n1 n2 ...)
;;(<= n1 n2 ...)

;;常规数字比较操作
;;复数在实部和虚部全部相等的情况下是相等的.如果比较的数字包括了NaNs的话会返回#f.

;+
;-
;*
;/

(+)
(*)

;;negative? positive? 正复数
;;even? odd?  奇偶数
;;finite? infinite? 是否是有限数
;;nan? 是否是NaN,


;;(quotient int1 int2) (remainder int1 int2)
;;int1 除以int2得到的商数和余数

;;(modulo int1 int2) 取模余数;

;;remainder的到的值符号和int1相同,而modulo得到的值和int2相同

;;(div x1 x2)
;;(mod x1 x2)
;;(div-and-mod x1 x2)

;;按照数字理论的整数除法和对应的remainder或者modulo.都可以用在实数上
;;div-and-mod 是一个多值返回,同时包括商和余数


;;div0 mod0 div0-and-mod0 和上一组类似
;;判别式是 x1=n*x2+m   -|x2/2| <= m < |x2/2|



;;(truncate real)
;;real向0方向最接近的一个整数



;;(flool real)
;;real向负无穷方向最接近的一个整数


;;(ceiling real)

;;real 在正无穷方向最接近的一个整数

;;(round real)
;;real最接近的整数

;;(abs real)
;;real的绝对值

;;(max real1 real2 real3 ...)
;;real1 real2 。。。的最大值


;;min 最小值

;;(gcd int ...)
;;最大公约数
(gcd)
(gcd 34)
(gcd 33 15)
(gcd 70 -42 28)

;;(lcm int ...)
;;int的最小公倍数

(lcm)
(lcm 34)
(lcm 33.0 15.0)
(lcm 70 -42 28)
(lcm 17.0 0)


;;(expt num1 num2)
;;num1的num2次

(expt 2 10)
(expt 2 -10)
(expt 2 -10.0)
(expt -1/2 5)
(expt 3.0 3)
(expt +i 2)


;;exact inexact
;; exact->inexact inexact->exact

;;将数字进行精确和非精确的转换



